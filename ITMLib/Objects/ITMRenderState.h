// Copyright 2014-2015 Isis Innovation Limited and the authors of InfiniTAM

#pragma once


#include <stdlib.h>

#include "../Utils/ITMLibDefines.h"
#include "../Engine/DeviceSpecific/CUDA/ITMCUDAUtils.h"
#include "../../ORUtils/Image.h"

namespace ITMLib
{
	namespace Objects
	{
		/** \brief
			Stores the render state used by the SceneReconstruction
			and Visualisation engines.
			*/
		class ITMRenderState
        {
		public:
            struct EntryVisibilityInformation {
            public:
                EntryVisibilityInformation(const int noTotalEntries) : 
                    visibleEntryIDs(SDF_LOCAL_BLOCK_NUM, MEMORYDEVICE_CUDA),
                    entriesVisibleType(noTotalEntries, MEMORYDEVICE_CUDA) {

                    cudaMallocManaged(&noVisibleEntries, sizeof(int));
                    cudaDeviceSynchronize();
                    *noVisibleEntries = 0;

                }

                /** Number of entries valid in visibleEntryIDs list. 
                Managed memory. */
                int* noVisibleEntries;

                /** compacted hash-table-entry ids j of those with entriesVisibleType[j] == VT_VISIBLE

                at most SDF_LOCAL_BLOCK_NUM many, valid up to noVisibleEntries-1
                */
                ORUtils::MemoryBlock<int> visibleEntryIDs;

                /** Per hash-table-entry visibility information.

                noTotalEntries == SDF_GLOBAL_BLOCK_NUM many
                */
                ORUtils::MemoryBlock<uchar> entriesVisibleType;
            };
            EntryVisibilityInformation* const entryVisibilityInformation;


			/** @brief
			Gives the raycasting operations an idea of the
			depth range to cover

			Each pixel contains an expected minimum and maximum
			depth. The raycasting step would use this
			information to reduce the range for searching an
			intersection with the actual surface. Should be
			updated by a ITMLib::Engine::ITMVisualisationEngine
			before any raycasting operation.

            Initialized to (vf_min, vf_max)

            Used by ITMVisualisationEngine::CreateExpectedDepths.
			*/
			ORUtils::Image<Vector2f> *renderingRangeImage;

			/** the 3D intersection locations generated by the latest raycast
            in voxel-fractional-world-coordinates!

            World-coordinate version of this is stored in trackingState->pointCloud->locations
			*/
			ORUtils::Image<Vector4f> *raycastResult;

			ORUtils::Image<Vector4u> *raycastImage;

            ITMRenderState(
                const int noTotalEntries,
                const Vector2i &imgSize,
                float vf_min, float vf_max,
                MemoryDeviceType memoryType) : 
                entryVisibilityInformation(new EntryVisibilityInformation(noTotalEntries))
			{
				renderingRangeImage = new ORUtils::Image<Vector2f>(imgSize, memoryType);
				raycastResult = new ORUtils::Image<Vector4f>(imgSize, memoryType);
				raycastImage = new ORUtils::Image<Vector4u>(imgSize, memoryType);

                // Initialize renderingRangeImage to (vf_min, vf_max)
                Vector2f v_lims(vf_min, vf_max);
				ORUtils::Image<Vector2f> *buffImage = new ORUtils::Image<Vector2f>(imgSize, MEMORYDEVICE_CPU);
				for (int i = 0; i < imgSize.x * imgSize.y; i++) buffImage->GetData(MEMORYDEVICE_CPU)[i] = v_lims;

				if (memoryType == MEMORYDEVICE_CUDA)
                    renderingRangeImage->SetFrom(buffImage, ORUtils::MemoryBlock<Vector2f>::CPU_TO_CUDA);
				else
                    renderingRangeImage->SetFrom(buffImage, ORUtils::MemoryBlock<Vector2f>::CPU_TO_CPU);

				delete buffImage;
			}

			virtual ~ITMRenderState()
			{
				delete renderingRangeImage;
				delete raycastResult;
				delete raycastImage;
			}
		};
	}
}
