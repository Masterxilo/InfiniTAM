// Copyright 2014-2015 Isis Innovation Limited and the authors of InfiniTAM

#pragma once


#include <stdlib.h>

#include "ITMLibDefines.h"
#include "ITMCUDAUtils.h"
#include "Image.h"

namespace ITMLib
{
	namespace Objects
	{
		/** \brief
			Stores the render state used by the Visualisation engine.
			*/
		class ITMRenderState
        {
		public:

			/** @brief
			Gives the raycasting operations an idea of the
			depth range to cover

			Each pixel contains an expected minimum and maximum
			depth. The raycasting step would use this
			information to reduce the range for searching an
			intersection with the actual surface. Should be
			updated by a ITMLib::Engine::ITMVisualisationEngine
			before any raycasting operation.

            Initialized to (vf_min, vf_max)

            Used by ITMVisualisationEngine::CreateExpectedDepths.
			*/
			ORUtils::Image<Vector2f> *renderingRangeImage;

			/** the 3D intersection locations generated by the latest raycast
            in voxel-fractional-world-coordinates!

            World-coordinate version of this is stored in trackingState->pointCloud->locations
			*/
			ORUtils::Image<Vector4f> *raycastResult;

            ITMRenderState(const Vector2i &imgSize) 
			{
                renderingRangeImage = new ORUtils::Image<Vector2f>(imgSize, MEMORYDEVICE_CUDA);
                raycastResult = new ORUtils::Image<Vector4f>(imgSize, MEMORYDEVICE_CUDA);
			}

			virtual ~ITMRenderState()
			{
				delete renderingRangeImage;
				delete raycastResult;
			}
		};
	}
}
