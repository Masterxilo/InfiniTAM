// Copyright 2014-2015 Isis Innovation Limited and the authors of InfiniTAM

#pragma once


#include <stdlib.h>

#include "../Utils/ITMLibDefines.h"
#include "../../ORUtils/Image.h"

namespace ITMLib
{
	namespace Objects
	{
		/** \brief
			Stores the render state used by the SceneReconstruction
			and Visualisation engines.
			*/
		class ITMRenderState
        {
        private:
            MemoryDeviceType memoryType;

            /** A list of "visible entries", that are currently
            being processed by the tracker.

            at most SDF_LOCAL_BLOCK_NUM many, valid up to noVisibleEntries-1
            */
            ORUtils::MemoryBlock<int> visibleEntryIDs;

            /** A list of "visible entries", that are
            currently being processed by integration
            and tracker.

            SDF_GLOBAL_BLOCK_NUM many
            */
            ORUtils::MemoryBlock<uchar> entriesVisibleType;
		public:

            /** Number of entries in the live list. */
            int noVisibleEntries;

            /** Get the list of "visible entries", that are currently
            processed by the tracker.

            noTotalEntries == SDF_GLOBAL_BLOCK_NUM many
            */
            const int *GetVisibleEntryIDs(void) const { return visibleEntryIDs.GetData(memoryType); }
            int *GetVisibleEntryIDs(void) { return visibleEntryIDs.GetData(memoryType); }
            uchar *GetEntriesVisibleType(void) { return entriesVisibleType.GetData(memoryType); }


			/** @brief
			Gives the raycasting operations an idea of the
			depth range to cover

			Each pixel contains an expected minimum and maximum
			depth. The raycasting step would use this
			information to reduce the range for searching an
			intersection with the actual surface. Should be
			updated by a ITMLib::Engine::ITMVisualisationEngine
			before any raycasting operation.

            Initialized to (vf_min, vf_max)
			*/
			ORUtils::Image<Vector2f> *renderingRangeImage;

			/** the 3D intersection locations generated by the latest raycast
            in voxel-fractional-world-coordinates
			*/
			ORUtils::Image<Vector4f> *raycastResult;

			ORUtils::Image<Vector4u> *raycastImage;

            ITMRenderState(
                int noTotalEntries,
                const Vector2i &imgSize,
                float vf_min, float vf_max,
                MemoryDeviceType memoryType) : 
                memoryType(memoryType),
                visibleEntryIDs(SDF_LOCAL_BLOCK_NUM, memoryType),
                entriesVisibleType(noTotalEntries, memoryType), 
                noVisibleEntries(0)
			{
				renderingRangeImage = new ORUtils::Image<Vector2f>(imgSize, memoryType);
				raycastResult = new ORUtils::Image<Vector4f>(imgSize, memoryType);
				raycastImage = new ORUtils::Image<Vector4u>(imgSize, memoryType);

                // Initialize renderingRangeImage to (vf_min, vf_max)
                Vector2f v_lims(vf_min, vf_max);
				ORUtils::Image<Vector2f> *buffImage = new ORUtils::Image<Vector2f>(imgSize, MEMORYDEVICE_CPU);
				for (int i = 0; i < imgSize.x * imgSize.y; i++) buffImage->GetData(MEMORYDEVICE_CPU)[i] = v_lims;

				if (memoryType == MEMORYDEVICE_CUDA)
                    renderingRangeImage->SetFrom(buffImage, ORUtils::MemoryBlock<Vector2f>::CPU_TO_CUDA);
				else
                    renderingRangeImage->SetFrom(buffImage, ORUtils::MemoryBlock<Vector2f>::CPU_TO_CPU);

				delete buffImage;
			}

			virtual ~ITMRenderState()
			{
				delete renderingRangeImage;
				delete raycastResult;
				delete raycastImage;
			}
		};
	}
}
